# stuck R2移行 実装計画書

## プロジェクト概要

### 目的
stuckアプリケーションのパフォーマンス改善とスケーラビリティ確保のため、記事コンテンツをCloudflare R2ストレージに移行し、D1にはメタデータのみを格納する構成に変更する。

### 変更の背景
- **現状の課題**
  - 記事一覧API: 504KB（全53記事のコンテンツ込み）の無駄な転送
  - D1の容量制限（単一DB 500MB、単一行 1MB）によるスケーラビリティ制約
  - N+1クエリ問題（54回のDB往復）

- **実測データ**
  - 記事数: 53件
  - 総コンテンツサイズ: 516,448 bytes（約504KB）
  - 平均記事サイズ: 9,744 bytes（約9.5KB）
  - 最大記事サイズ: 161KB（要件定義書など）

### 期待される効果
- 記事一覧APIレスポンスサイズ: **504KB → 20KB（95%削減）**
- DBクエリ数: **54回 → 2回（96%削減）**
- 大容量記事（数MB級）の格納が可能に
- 将来的な全文検索（Vectorize）との連携基盤

---

## システムアーキテクチャ

### 現在の構成（Before）

```
┌─────────────────────────────────────┐
│  D1 Database (stuck-db)             │
│  ├─ articles                        │
│  │  ├─ id                           │
│  │  ├─ title                        │
│  │  ├─ content (Markdown 全文)      │  ← パフォーマンスボトルネック
│  │  ├─ memo                         │
│  │  ├─ created_at                   │
│  │  ├─ updated_at                   │
│  │  └─ deleted_at                   │
│  ├─ tags                            │
│  └─ article_tags                    │
└─────────────────────────────────────┘
```

### 移行後の構成（After）

```
┌─────────────────────────────────────┐    ┌──────────────────────────┐
│  D1 Database (stuck-db)             │    │  R2 Storage              │
│  ├─ articles                        │    │  (stuck-articles)        │
│  │  ├─ id                           │    │  ├─ articles/1.md        │
│  │  ├─ title                        │    │  ├─ articles/2.md        │
│  │  ├─ content_key (R2パス)         │◄───┤  └─ articles/53.md       │
│  │  ├─ content_size (bytes)         │    └──────────────────────────┘
│  │  ├─ content_hash (SHA-256)       │
│  │  ├─ memo                         │
│  │  ├─ created_at                   │
│  │  ├─ updated_at                   │
│  │  └─ deleted_at                   │
│  ├─ tags                            │
│  └─ article_tags                    │
└─────────────────────────────────────┘
```

### データフロー

#### 記事一覧取得（最適化済み）
```
GET /api/articles
  ↓
[API Handler]
  ↓
SELECT id, title, memo, content_size, created_at, updated_at, deleted_at
FROM articles WHERE deleted_at IS NULL
  ↓
JOIN tags (一括取得でN+1解消)
  ↓
返却: メタデータのみ（20KB）
```

#### 記事詳細取得（R2から遅延読み込み）
```
GET /api/articles/:id
  ↓
[API Handler]
  ↓
D1: SELECT * FROM articles WHERE id = ?
  ↓
R2: GET articles/{id}.md （content_keyを使用）
  ↓
返却: メタデータ + R2コンテンツ
```

#### 記事作成・更新
```
POST/PUT /api/articles
  ↓
[API Handler]
  ↓
1. R2: PUT articles/{id}.md （コンテンツ保存）
  ↓
2. D1: INSERT/UPDATE articles (メタデータのみ)
     - content_key = "articles/{id}.md"
     - content_size = byte length
     - content_hash = SHA-256(content)
  ↓
3. D1: タグ関連付け
  ↓
返却: 保存結果
```

---

## データベーススキーマ変更

### マイグレーションSQL

**ファイル**: `D:\github\stuck\migrations\001_add_r2_support.sql`

```sql
-- 新規カラム追加
ALTER TABLE articles ADD COLUMN content_key TEXT;
ALTER TABLE articles ADD COLUMN content_size INTEGER;
ALTER TABLE articles ADD COLUMN content_hash TEXT;

-- インデックス追加（パフォーマンス最適化）
CREATE INDEX IF NOT EXISTS idx_articles_content_key ON articles(content_key);

-- 既存データの一時的な処理（後でマイグレーションスクリプトで更新）
-- content カラムは後方互換性のため一時的に残す
```

### 型定義の更新

**ファイル**: `D:\github\stuck\lib\db\types.ts`

```typescript
export interface Article {
  id: number;
  title: string;
  content?: string;              // オプションに変更（R2から取得時のみ存在）
  content_key: string | null;    // R2オブジェクトキー（例: "articles/123.md"）
  content_size: number | null;   // コンテンツサイズ（bytes）
  content_hash: string | null;   // SHA-256ハッシュ（整合性検証用）
  memo: string | null;
  created_at: string;
  updated_at: string;
  deleted_at: string | null;
  tags?: Tag[];
}

export interface ArticleMetadata {
  id: number;
  title: string;
  content_key: string | null;
  content_size: number | null;
  content_hash: string | null;
  memo: string | null;
  created_at: string;
  updated_at: string;
  deleted_at: string | null;
  tags?: Tag[];
}
```

---

## 実装ファイル一覧

### 1. R2ストレージユーティリティ

**ファイル**: `D:\github\stuck\lib\storage.ts`

```typescript
/**
 * R2ストレージ操作ユーティリティ
 */

export interface StorageConfig {
  bucket: R2Bucket;
}

export class ArticleStorage {
  constructor(private config: StorageConfig) {}

  /**
   * 記事コンテンツをR2に保存
   */
  async saveContent(articleId: number, content: string): Promise<{
    key: string;
    size: number;
    hash: string;
  }> {
    const key = `articles/${articleId}.md`;
    const buffer = new TextEncoder().encode(content);
    const hash = await this.calculateHash(buffer);

    await this.config.bucket.put(key, buffer, {
      httpMetadata: {
        contentType: 'text/markdown; charset=utf-8',
      },
      customMetadata: {
        articleId: articleId.toString(),
        hash,
      },
    });

    return {
      key,
      size: buffer.byteLength,
      hash,
    };
  }

  /**
   * 記事コンテンツをR2から取得
   */
  async getContent(key: string): Promise<string | null> {
    const object = await this.config.bucket.get(key);
    if (!object) return null;

    return await object.text();
  }

  /**
   * 記事コンテンツを削除（論理削除対応）
   */
  async deleteContent(key: string): Promise<void> {
    await this.config.bucket.delete(key);
  }

  /**
   * SHA-256ハッシュ計算
   */
  private async calculateHash(data: Uint8Array): Promise<string> {
    const hashBuffer = await crypto.subtle.digest('SHA-256', data);
    const hashArray = Array.from(new Uint8Array(hashBuffer));
    return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
  }
}
```

---

### 2. D1データベース操作の更新

**ファイル**: `D:\github\stuck\lib\db\d1.ts`

主な変更点:

#### `getArticles()` - 記事一覧取得（最適化）

```typescript
export async function getArticles(db: D1Database): Promise<ArticleMetadata[]> {
  // contentカラムを除外してメタデータのみ取得
  const { results } = await db.prepare(`
    SELECT
      id, title, content_key, content_size, content_hash, memo,
      created_at, updated_at, deleted_at
    FROM articles
    WHERE deleted_at IS NULL
    ORDER BY created_at DESC
  `).all();

  const articles = results as ArticleMetadata[];
  const articleIds = articles.map(a => a.id);

  if (articleIds.length === 0) return [];

  // タグを一括取得（N+1問題解消）
  const placeholders = articleIds.map(() => '?').join(',');
  const { results: tagResults } = await db.prepare(`
    SELECT at.article_id, t.id, t.name, t.created_at
    FROM article_tags at
    INNER JOIN tags t ON at.tag_id = t.id
    WHERE at.article_id IN (${placeholders})
  `).bind(...articleIds).all();

  // タグをマッピング
  const tagMap = new Map<number, Tag[]>();
  for (const row of tagResults as any[]) {
    if (!tagMap.has(row.article_id)) {
      tagMap.set(row.article_id, []);
    }
    tagMap.get(row.article_id)!.push({
      id: row.id,
      name: row.name,
      created_at: row.created_at,
    });
  }

  // タグを記事に関連付け
  for (const article of articles) {
    article.tags = tagMap.get(article.id) || [];
  }

  return articles;
}
```

#### `getArticleById()` - 記事詳細取得（R2連携）

```typescript
export async function getArticleById(
  db: D1Database,
  storage: ArticleStorage,
  id: number
): Promise<Article | null> {
  // メタデータ取得
  const { results } = await db.prepare(`
    SELECT * FROM articles WHERE id = ? AND deleted_at IS NULL
  `).bind(id).all();

  if (results.length === 0) return null;

  const article = results[0] as Article;

  // タグ取得
  const { results: tags } = await db.prepare(`
    SELECT t.* FROM tags t
    INNER JOIN article_tags at ON t.id = at.tag_id
    WHERE at.article_id = ?
  `).bind(id).all();

  article.tags = tags as Tag[];

  // R2からコンテンツ取得
  if (article.content_key) {
    article.content = await storage.getContent(article.content_key);
  }

  return article;
}
```

#### `createArticle()` - 記事作成（R2対応）

```typescript
export async function createArticle(
  db: D1Database,
  storage: ArticleStorage,
  data: { title: string; content: string; memo?: string; tags?: string[] }
): Promise<number> {
  const { title, content, memo, tags } = data;

  // 1. D1に仮レコード作成（IDを取得）
  const { meta } = await db.prepare(`
    INSERT INTO articles (title, memo) VALUES (?, ?)
  `).bind(title, memo || null).run();

  const articleId = meta.last_row_id!;

  // 2. R2にコンテンツ保存
  const { key, size, hash } = await storage.saveContent(articleId, content);

  // 3. D1のレコードを更新
  await db.prepare(`
    UPDATE articles
    SET content_key = ?, content_size = ?, content_hash = ?, updated_at = CURRENT_TIMESTAMP
    WHERE id = ?
  `).bind(key, size, hash, articleId).run();

  // 4. タグ処理（既存ロジック流用）
  if (tags && tags.length > 0) {
    await updateArticleTags(db, articleId, tags);
  }

  return articleId;
}
```

#### `updateArticle()` - 記事更新（R2対応）

```typescript
export async function updateArticle(
  db: D1Database,
  storage: ArticleStorage,
  id: number,
  data: { title?: string; content?: string; memo?: string; tags?: string[] }
): Promise<Article | null> {
  const { title, content, memo, tags } = data;

  // 既存記事取得
  const existing = await db.prepare(`
    SELECT * FROM articles WHERE id = ? AND deleted_at IS NULL
  `).bind(id).all();

  if (existing.results.length === 0) return null;

  const article = existing.results[0] as Article;

  // コンテンツ更新（変更がある場合）
  if (content !== undefined) {
    const { key, size, hash } = await storage.saveContent(id, content);

    await db.prepare(`
      UPDATE articles
      SET content_key = ?, content_size = ?, content_hash = ?, updated_at = CURRENT_TIMESTAMP
      WHERE id = ?
    `).bind(key, size, hash, id).run();
  }

  // メタデータ更新
  if (title !== undefined || memo !== undefined) {
    await db.prepare(`
      UPDATE articles
      SET
        title = COALESCE(?, title),
        memo = COALESCE(?, memo),
        updated_at = CURRENT_TIMESTAMP
      WHERE id = ?
    `).bind(title, memo, id).run();
  }

  // タグ更新
  if (tags !== undefined) {
    await updateArticleTags(db, id, tags);
  }

  // 更新後のデータ取得
  return await getArticleById(db, storage, id);
}
```

#### `deleteArticle()` - 論理削除（R2は保持）

```typescript
export async function deleteArticle(
  db: D1Database,
  id: number
): Promise<boolean> {
  const { meta } = await db.prepare(`
    UPDATE articles SET deleted_at = CURRENT_TIMESTAMP WHERE id = ?
  `).bind(id).run();

  // NOTE: R2のコンテンツは削除しない（復元可能性のため）
  // 完全削除が必要な場合は別途purgeArticle()を実装

  return meta.changes > 0;
}
```

---

### 3. API Routeの更新

**ファイル**: `D:\github\stuck\app\api\articles\route.ts`

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { getArticles, createArticle } from '@/lib/db/d1';
import { ArticleStorage } from '@/lib/storage';

export const runtime = 'edge';

interface Env {
  DB: D1Database;
  ARTICLES_BUCKET: R2Bucket;  // 新規追加
}

export async function GET(request: NextRequest) {
  const env = process.env as unknown as Env;

  try {
    const articles = await getArticles(env.DB);

    return NextResponse.json({ articles });
  } catch (error) {
    console.error('Failed to fetch articles:', error);
    return NextResponse.json(
      { error: 'Internal server error' },
      { status: 500 }
    );
  }
}

export async function POST(request: NextRequest) {
  const env = process.env as unknown as Env;
  const storage = new ArticleStorage({ bucket: env.ARTICLES_BUCKET });

  try {
    const data = await request.json();
    const { title, content, memo, tags } = data;

    if (!title || !content) {
      return NextResponse.json(
        { error: 'Title and content are required' },
        { status: 400 }
      );
    }

    const articleId = await createArticle(env.DB, storage, {
      title,
      content,
      memo,
      tags,
    });

    return NextResponse.json({ id: articleId }, { status: 201 });
  } catch (error) {
    console.error('Failed to create article:', error);
    return NextResponse.json(
      { error: 'Internal server error' },
      { status: 500 }
    );
  }
}
```

**ファイル**: `D:\github\stuck\app\api\articles\[id]\route.ts`

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { getArticleById, updateArticle, deleteArticle } from '@/lib/db/d1';
import { ArticleStorage } from '@/lib/storage';

export const runtime = 'edge';

interface Env {
  DB: D1Database;
  ARTICLES_BUCKET: R2Bucket;
}

export async function GET(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  const env = process.env as unknown as Env;
  const storage = new ArticleStorage({ bucket: env.ARTICLES_BUCKET });
  const id = parseInt(params.id);

  try {
    const article = await getArticleById(env.DB, storage, id);

    if (!article) {
      return NextResponse.json(
        { error: 'Article not found' },
        { status: 404 }
      );
    }

    return NextResponse.json({ article });
  } catch (error) {
    console.error('Failed to fetch article:', error);
    return NextResponse.json(
      { error: 'Internal server error' },
      { status: 500 }
    );
  }
}

export async function PUT(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  const env = process.env as unknown as Env;
  const storage = new ArticleStorage({ bucket: env.ARTICLES_BUCKET });
  const id = parseInt(params.id);

  try {
    const data = await request.json();
    const article = await updateArticle(env.DB, storage, id, data);

    if (!article) {
      return NextResponse.json(
        { error: 'Article not found' },
        { status: 404 }
      );
    }

    return NextResponse.json({ article });
  } catch (error) {
    console.error('Failed to update article:', error);
    return NextResponse.json(
      { error: 'Internal server error' },
      { status: 500 }
    );
  }
}

export async function DELETE(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  const env = process.env as unknown as Env;
  const id = parseInt(params.id);

  try {
    const success = await deleteArticle(env.DB, id);

    if (!success) {
      return NextResponse.json(
        { error: 'Article not found' },
        { status: 404 }
      );
    }

    return NextResponse.json({ success: true });
  } catch (error) {
    console.error('Failed to delete article:', error);
    return NextResponse.json(
      { error: 'Internal server error' },
      { status: 500 }
    );
  }
}
```

---

### 4. wrangler.toml更新

**ファイル**: `D:\github\stuck\wrangler.toml`

```toml
name = "stuck"
compatibility_date = "2024-01-01"

# D1 Database Binding
[[d1_databases]]
binding = "DB"
database_name = "stuck-db"
database_id = "89ed51c8-0869-4192-af68-48fa1c601cc3"

# R2 Bucket Binding（新規追加）
[[r2_buckets]]
binding = "ARTICLES_BUCKET"
bucket_name = "stuck-articles"
```

---

## マイグレーション戦略

### Phase 1: インフラ準備

#### 1-1. R2バケット作成

```bash
cd D:\github\stuck
npx wrangler r2 bucket create stuck-articles
```

#### 1-2. D1スキーマ変更

```bash
# マイグレーションファイル適用
npx wrangler d1 execute stuck-db --remote --file=./migrations/001_add_r2_support.sql
```

#### 1-3. wrangler.toml更新

上記の設定を追加後、デプロイテスト:

```bash
npm run pages:build
npm run preview
```

---

### Phase 2: コード実装

#### 2-1. ファイル作成順序

1. `lib/storage.ts` - R2ユーティリティ
2. `lib/db/types.ts` - 型定義更新
3. `lib/db/d1.ts` - DB操作更新
4. `app/api/articles/route.ts` - 一覧・作成API
5. `app/api/articles/[id]/route.ts` - 詳細・更新・削除API

#### 2-2. 動作確認

- ローカル開発環境（`npm run dev`）でテスト
- Cloudflare Pages Preview環境でテスト

---

### Phase 3: データマイグレーション

#### 3-1. 既存53記事のR2移行スクリプト

**ファイル**: `D:\github\stuck\scripts\migrate-to-r2.ts`

```typescript
/**
 * 既存記事をR2に移行するスクリプト
 *
 * 実行方法:
 * npx tsx scripts/migrate-to-r2.ts
 */

import { ArticleStorage } from '../lib/storage';

interface Env {
  DB: D1Database;
  ARTICLES_BUCKET: R2Bucket;
}

async function migrateArticlesToR2(env: Env) {
  const storage = new ArticleStorage({ bucket: env.ARTICLES_BUCKET });

  // 1. content カラムがある記事を全取得
  const { results } = await env.DB.prepare(`
    SELECT id, title, content
    FROM articles
    WHERE content IS NOT NULL AND content_key IS NULL
  `).all();

  console.log(`Found ${results.length} articles to migrate`);

  let successCount = 0;
  let errorCount = 0;

  for (const row of results as any[]) {
    try {
      console.log(`Migrating article ${row.id}: ${row.title}`);

      // 2. R2に保存
      const { key, size, hash } = await storage.saveContent(row.id, row.content);

      // 3. D1更新
      await env.DB.prepare(`
        UPDATE articles
        SET content_key = ?, content_size = ?, content_hash = ?
        WHERE id = ?
      `).bind(key, size, hash, row.id).run();

      successCount++;
      console.log(`✓ Migrated: ${key} (${size} bytes)`);
    } catch (error) {
      errorCount++;
      console.error(`✗ Failed to migrate article ${row.id}:`, error);
    }
  }

  console.log(`\n=== Migration Complete ===`);
  console.log(`Success: ${successCount}`);
  console.log(`Error: ${errorCount}`);
}

// Cloudflare Workers環境で実行
export default {
  async fetch(request: Request, env: Env) {
    await migrateArticlesToR2(env);
    return new Response('Migration complete', { status: 200 });
  },
};
```

#### 3-2. マイグレーション実行

```bash
# 一時的なワーカーとしてデプロイ
npx wrangler deploy scripts/migrate-to-r2.ts --name stuck-migration

# HTTPリクエストでトリガー
curl https://stuck-migration.belong2jazz.workers.dev

# 完了後、ワーカー削除
npx wrangler delete stuck-migration
```

#### 3-3. データ検証

```bash
# R2のオブジェクト数確認
npx wrangler r2 object list stuck-articles --prefix articles/

# D1のメタデータ確認
npx wrangler d1 execute stuck-db --remote --command "SELECT COUNT(*) FROM articles WHERE content_key IS NOT NULL"
```

---

### Phase 4: 旧カラム削除（オプション）

マイグレーション完了後、`content` カラムは不要になるため削除可能:

```sql
-- バックアップ後に実行
ALTER TABLE articles DROP COLUMN content;
```

**注意**: SQLiteのALTER TABLE DROP COLUMNはバージョンによっては非対応。その場合は以下の手順:

```sql
-- 1. 新テーブル作成
CREATE TABLE articles_new (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  title TEXT NOT NULL,
  content_key TEXT,
  content_size INTEGER,
  content_hash TEXT,
  memo TEXT,
  created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
  updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
  deleted_at DATETIME DEFAULT NULL
);

-- 2. データコピー
INSERT INTO articles_new
SELECT id, title, content_key, content_size, content_hash, memo, created_at, updated_at, deleted_at
FROM articles;

-- 3. 旧テーブル削除・リネーム
DROP TABLE articles;
ALTER TABLE articles_new RENAME TO articles;

-- 4. インデックス再作成
CREATE INDEX idx_articles_deleted_at ON articles(deleted_at);
CREATE INDEX idx_articles_created_at ON articles(created_at);
CREATE INDEX idx_articles_content_key ON articles(content_key);
```

---

## MCP連携の考慮事項

### 現在のMCPサーバー仕様（復習）

**ファイル**: `D:\github\mcp\unified-mcp-server\wrangler.toml`

```toml
[[d1_databases]]
binding = "MEMO_DB"
database_name = "stuck-db"
database_id = "89ed51c8-0869-4192-af68-48fa1c601cc3"
```

### R2移行後のMCPツール更新

**ファイル**: `D:\github\mcp\unified-mcp-server\src\modules\memo.ts`

MCPサーバーにもR2バインディングを追加し、記事取得時にR2からコンテンツを読み込む必要があります。

#### wrangler.toml更新（MCP側）

```toml
[[d1_databases]]
binding = "MEMO_DB"
database_name = "stuck-db"
database_id = "89ed51c8-0869-4192-af68-48fa1c601cc3"

[[r2_buckets]]
binding = "ARTICLES_BUCKET"  # 新規追加
bucket_name = "stuck-articles"
```

#### MCP ツール実装例

```typescript
// memo.get_article - 記事詳細取得
{
  name: 'memo.get_article',
  description: 'stuckから記事詳細を取得（R2からコンテンツを読み込み）',
  inputSchema: {
    type: 'object',
    properties: {
      id: { type: 'number', description: '記事ID' },
    },
    required: ['id'],
  },
  handler: async (args, env) => {
    const { id } = args;

    // D1からメタデータ取得
    const article = await env.MEMO_DB.prepare(`
      SELECT * FROM articles WHERE id = ? AND deleted_at IS NULL
    `).bind(id).first();

    if (!article) {
      throw new Error(`Article ${id} not found`);
    }

    // R2からコンテンツ取得
    if (article.content_key) {
      const object = await env.ARTICLES_BUCKET.get(article.content_key);
      if (object) {
        article.content = await object.text();
      }
    }

    return { article };
  },
}
```

---

## テスト計画

### 単体テスト

#### ArticleStorage クラス

- `saveContent()` - R2への保存成功
- `getContent()` - R2からの取得成功
- `deleteContent()` - R2からの削除成功
- `calculateHash()` - SHA-256計算の正確性

#### D1操作関数

- `getArticles()` - メタデータのみ取得、タグ一括読み込み
- `getArticleById()` - R2コンテンツ付き取得
- `createArticle()` - R2 + D1の連携動作
- `updateArticle()` - 部分更新の正確性
- `deleteArticle()` - 論理削除

### 統合テスト

#### API E2Eテスト

```typescript
describe('Articles API with R2', () => {
  it('POST /api/articles - 新規記事作成', async () => {
    const response = await fetch('https://stuck-bwf.pages.dev/api/articles', {
      method: 'POST',
      headers: {
        'Authorization': 'Basic ...',
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        title: 'Test Article',
        content: '# Hello R2',
        memo: 'Test memo',
        tags: ['tech'],
      }),
    });

    expect(response.status).toBe(201);
    const { id } = await response.json();
    expect(id).toBeGreaterThan(0);
  });

  it('GET /api/articles - 記事一覧取得（contentなし）', async () => {
    const response = await fetch('https://stuck-bwf.pages.dev/api/articles');
    const { articles } = await response.json();

    expect(articles[0]).not.toHaveProperty('content');
    expect(articles[0]).toHaveProperty('content_key');
    expect(articles[0]).toHaveProperty('content_size');
  });

  it('GET /api/articles/:id - 記事詳細取得（contentあり）', async () => {
    const response = await fetch('https://stuck-bwf.pages.dev/api/articles/1');
    const { article } = await response.json();

    expect(article).toHaveProperty('content');
    expect(article.content).toContain('# Hello R2');
  });
});
```

### パフォーマンステスト

#### 記事一覧API（最重要）

```bash
# Before: 504KB
curl -w "@curl-format.txt" https://stuck-bwf.pages.dev/api/articles

# After: 20KB期待
# time_total, size_download を計測
```

#### 記事詳細API

```bash
# R2レイテンシ計測
# 目標: 200ms以内
```

---

## ロールバック計画

### 緊急時の復旧手順

1. **wrangler.tomlを元に戻す**
   - R2バインディングをコメントアウト

2. **コードをロールバック**
   ```bash
   git revert <commit-hash>
   npm run deploy
   ```

3. **D1データの復旧**
   - content カラムは削除していないため、そのまま利用可能
   - マイグレーション前のバックアップから復元

### データバックアップ

```bash
# マイグレーション前に必ず実行
npx wrangler d1 export stuck-db --remote --output=backup-$(date +%Y%m%d).sql
```

---

## スケジュール

| フェーズ | 作業内容 | 所要時間 | 担当 |
|---------|---------|---------|------|
| Phase 1 | インフラ準備（R2バケット、スキーマ変更） | 30分 | Claude Code |
| Phase 2 | コード実装（storage.ts, d1.ts, API） | 2-3時間 | Claude Code |
| Phase 3 | データマイグレーション（53記事） | 1時間 | Claude Code |
| Phase 4 | テスト・検証 | 1時間 | まさゆき + Claude Code |
| Phase 5 | 本番デプロイ | 30分 | Claude Code |
| Phase 6 | MCP連携更新 | 1時間 | Claude Code |

**合計**: 約6-7時間

---

## リスクと対策

| リスク | 影響度 | 対策 |
|--------|--------|------|
| マイグレーション中のデータ損失 | 高 | バックアップ必須、段階的移行 |
| R2レイテンシによる詳細画面遅延 | 中 | キャッシュ戦略、CDN活用 |
| MCPサーバーとの整合性問題 | 中 | 同時更新、バージョン管理 |
| 既存フロントエンドの互換性 | 低 | 型定義の後方互換性維持 |

---

## 成果物チェックリスト

### コード

- [ ] `lib/storage.ts` - R2ユーティリティ
- [ ] `lib/db/types.ts` - 型定義更新
- [ ] `lib/db/d1.ts` - DB操作更新
- [ ] `app/api/articles/route.ts` - 一覧・作成API
- [ ] `app/api/articles/[id]/route.ts` - 詳細・更新・削除API
- [ ] `migrations/001_add_r2_support.sql` - マイグレーションSQL
- [ ] `scripts/migrate-to-r2.ts` - データ移行スクリプト

### インフラ

- [ ] R2バケット `stuck-articles` 作成
- [ ] wrangler.toml更新（R2バインディング）
- [ ] D1スキーマ変更適用

### テスト

- [ ] 単体テスト実装
- [ ] API E2Eテスト
- [ ] パフォーマンステスト（Before/After比較）

### ドキュメント

- [ ] README.md更新（R2構成の説明）
- [ ] API仕様書更新
- [ ] マイグレーション手順書

### MCP連携

- [ ] MCPサーバーのwrangler.toml更新
- [ ] MCPツールのR2対応
- [ ] 動作確認

---

## 承認・レビュー

- **計画作成日**: 2025-10-28
- **計画承認日**: （承認後記入）
- **承認者**: まさゆき
- **実装担当**: Claude Code

---

## 関連ドキュメント

- `D:\github\stuck\docs\次回改善.md` - 今回の要望元ドキュメント
- `D:\github\stuck\schema.sql` - 現在のDBスキーマ
- `D:\github\mcp\docs\実装計画書.md` - MCP統合サーバー仕様
- Cloudflare R2 公式ドキュメント: https://developers.cloudflare.com/r2/

---

## 次のアクション

実装を開始してよろしいでしょうか？

以下のいずれかを選択してください:

1. **すぐに実装開始** - Phase 1から順に実装
2. **設計の修正** - 何か変更したい点があれば指摘
3. **段階的実装** - まずPhase 1のみ実施してレビュー

ご指示をお願いします。
